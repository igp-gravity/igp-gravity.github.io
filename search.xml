<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[地震会商系统视频培训教程之二]]></title>
    <url>%2F2019%2F02%2F07%2Fispec20190207.html</url>
    <content type="text"><![CDATA[第1季第2集-如何设计你自己的工作流程？ 难度：容易 时长：约40分钟 对象：列装单位的负责人和业务人员 演示例子：有 要点提示：1、流程体系与工作流编辑器，Datist数据科学版获取、安装和环境特点；2、常用节点介绍；3、应用场景（数据绘图与可视化、数据统计与预处理、GIS与地震目录分析）。 知识点： 1、流程设计：Datist数据科学版安装和环境特点 2、节点用法：Datist数据科学版常用节点介绍 3、实例分析：数据绘图与可视化、数据统计与预处理、GIS与地震目录分析 (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"/attachs/ispecs1e2.mp4","pic":"/images/ispec.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 视频教程PPT下载演示流程实例DMS下载]]></content>
      <tags>
        <tag>ISPEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地震会商系统视频培训教程]]></title>
    <url>%2F2019%2F02%2F03%2Fispec20190203.html</url>
    <content type="text"><![CDATA[第1季第1集-地震分析会商技术系统是什么？ 难度：容易 时长：25-30分钟 对象：列装单位的负责人和业务人员 演示例子：无 要点提示：地震分析会商系统的缘起、设计、定位、组成和特点-20分钟；你必须知道的一些资源获取方法和学习方式（地震科研助手、小G、Datist流程设计软件）。 知识点： 1、地震信息化的核心是业务信息化 2、去中心化的运行理念 3、宽平台、厚技术、微应用 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"/attachs/ispecs1e1.mp4","pic":"/images/ispec.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 视频教程PPT下载]]></content>
      <tags>
        <tag>ISPEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鲁甸地震科技产品]]></title>
    <url>%2F2019%2F01%2F26%2Fvis20190126.html</url>
    <content type="text"><![CDATA[翻出几年前做的一段视频，新年开始准备继续从操旧业了…鲁甸地震后的一些科技产品(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"/attachs/XMLY1-R1-1n.mp4","pic":"/images/geoist-logo.PNG"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 视频下载]]></content>
      <tags>
        <tag>Visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九大工程项目设计]]></title>
    <url>%2F2018%2F12%2F11%2Fgeoist20181211.html</url>
    <content type="text"><![CDATA[今天在台网中心集中工作]]></content>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python绘图实践记录]]></title>
    <url>%2F2018%2F11%2F30%2Fpython20181130.html</url>
    <content type="text"><![CDATA[用Python进行数据分析少不了绘图工具matplotlib matplotlib是免费的，首先，应该确保环境已经安装matplotlib，numpy, mpl_toolkits，具体怎么做应该不用说了吧！ matplotlib是Python常用的数据绘制包。它基于numpy的数组运算功能。matplotlib绘图功能强大，可以轻易的画出各种统计图形，比如散点图，条行图，饼图等。matplotlib常与numpy和scipy相配合，用于许多研究领域。 二维绘图 基本图形绘制 123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0,10,1000)y = np.sin(x)z = np.cos(x)# 配置plt.figure(figsize=(8,4)) # 框的大小plt.plot(x,y,label=&apos;$sin(x)$&apos;)plt.plot(x,z,&apos;b--&apos;,label=&apos;$cos(x)$&apos;) # 蓝色虚线plt.xlabel(&quot;Time(s)&quot;)plt.ylabel(&quot;&quot;)plt.title(&quot;matplotlib&quot;)plt.ylim(-1.2, 1.2)plt.legend() # 显示为一个样式plt.show()fig = plt.gcf() # 获得当前图标的对象ax = plt.gca() # 获得子图的对象print figprint ax 多轴绘图 123456789# 多轴绘图# subplot(numRows, numCols, plotNum)import matplotlib.pyplot as pltfor idx, color in enumerate(&quot;rgbyck&quot;): plt.subplot(320+idx+1, axisbg=color)plt.show() 不同坐标系 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltw = np.linspace(0.1, 1000, 1000)p = np.abs(1/(1+0.1j*w))plt.subplot(221)plt.plot(w, p, linewidth=2) # 算术坐标系plt.ylim(0, 1.5)plt.subplot(222)plt.semilogx(w, p, linewidth=2) # x 对数坐标系plt.ylim(0, 1.5)plt.subplot(223)plt.semilogy(w, p, linewidth=2) # y 对数坐标系plt.ylim(0, 1.5)plt.subplot(224)plt.loglog(w, p, linewidth=2) # 对数坐标系plt.ylim(0, 1.5)plt.show() 柱状图 1234567# 1.txt的文本&gt;&gt;&gt; dataarray([[ 0., 10., 20., 30., 40.], [ 10., 23., 33., 43., 53.], [ 20., 83., 23., 55., 33.], [ 30., 93., 44., 22., 55.], [ 40., 72., 33., 44., 66.]]) 12345678910111213141516import numpy as npimport matplotlib.pyplot as pltdata = np.loadtxt(r&quot;D:\1.txt&quot;)width = (data[1, 0] - data[0, 0])*0.4 # 柱形的宽带为4# data[:, 0]：所有行数据# data[:, 1]：所有列数据 plt.figure() plt.bar(data[:, 0] - width, data[:, 1], width, label=&apos;person&apos;) plt.xlim(-width, 40) # x 的取值区间plt.xlabel(&quot;Age&quot;)plt.ylabel(&quot;Num&quot;)plt.legend()plt.show() 散点图 1234567891011121314import numpy as npimport matplotlib.pyplot as pltplt.figure()x = np.random.rand(100)y = np.random.rand(100) # marker:绘制点的形状和大小，5代表五边形，1是大小 # s的默认值是20plt.scatter(x, y, s=x*1000, c=y, marker=(5,1), lw=2, facecolor=&apos;none&apos;) # marker:绘制点的形状和大小 lw:linewidth facecolor:颜色plt.xlim(0, 1) # c:cmap不是color，cmap绘制出来是彩图（不同颜色）plt.ylim(0, 1)plt.show() 三维绘图（mpl_toolkits） 基本3D图 12345678# 3D图 import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = fig.add_subplot(111, projection=&apos;3d&apos;)plt.show() 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = fig.gca(projection=&apos;3d&apos;) # projection=&apos;3d&apos; 已经隐性调用了Axes3D# ax = Axes3D(fig) # 可以加上也可以不加th = np.linspace(-4 * np.pi, 4 * np.pi, 100)z = np.linspace(-2, 2, 100)r = z ** 2 + 1x = r * np.sin(th)y = r * np.cos(th)ax.plot(x, y, z, label=&apos;hello&apos;) # 立体的ax.legend()plt.show()ax.plot(x, y, label=&apos;hello&apos;) # 平面的 1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D def randrange(n, vmin, vmax): return (vmax-vmin)*np.random.rand(n) + vminfig = plt.figure()ax = fig.add_subplot(111, projection=&apos;3d&apos;)n = 100for c, m, zl, zh in [(&apos;r&apos;, &apos;o&apos;, -50, -25), (&apos;b&apos;, &apos;^&apos;, -30, -5)]: xs = randrange(n, 23, 32) ys = randrange(n, 0, 100) zs = randrange(n, zl, zh) ax.scatter(xs, ys, zs, c=c, marker=m)ax.set_xlabel(&apos;x&apos;)ax.set_ylabel(&apos;y&apos;)ax.set_zlabel(&apos;z&apos;)plt.show() 轮廓图 123456789101112131415import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import axes3dfrom matplotlib import cmfig = plt.figure()ax = fig.add_subplot(111, projection=&apos;3d&apos;)X, Y, Z = axes3d.get_test_data(0.05) # 生成一系列的测试数据cset = ax.contour(X, Y, Z,cmap=cm.coolwarm) # contour：生成轮廓图ax.clabel(cset, fontsize=9, inline=1)plt.show()# 修改cset = ax.contour(X, Y, Z,extend3d=True, cmap=cm.coolwarm) # 颜色的填充 3D柱形图 1234567891011121314151617import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport numpy as npfig = plt.figure()ax = fig.add_subplot(111, projection=&apos;3d&apos;)for c, z in zip([&apos;r&apos;, &apos;g&apos;, &apos;b&apos;, &apos;y&apos;], (30, 20, 10, 0)): x = np.arange(20) y = np.random.rand(20) cs = [c] * len(x) cs[0] = &apos;c&apos; ax.bar(x, y, zs=z, zdir=&apos;y&apos;, color = cs)ax.set_xlabel(&apos;x&apos;)plt.show() 绘制曲面 1234567891011121314import numpy as npfrom mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_subplot(111, projection=&apos;3d&apos;)u = np.linspace(0, 2*np.pi, 100)v = np.linspace(0, np.pi, 100)x = 10 * np.outer(np.cos(u), np.sin(v))y = 10 * np.outer(np.sin(u), np.sin(v))z = 10 * np.outer(np.ones(np.size(u)), np.cos(v))ax.plot_surface(x, y, z, rstride=4, cstride=4, color=&apos;b&apos;) 绘制文字 123456789101112131415161718192021222324252627from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = fig.gca(projection=&apos;3d&apos;)zdirs = (None, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, (1, 1, 0), (1, 1, 1))xs = (1, 4, 4, 9, 4, 1)ys = (2, 5, 8, 10, 1, 2)zs = (10,3, 8, 9, 1, 8)for zdir, x, y, z in zip(zdirs, xs, ys, zs): label = &apos;(%d, %d, %d), dir=%s&apos; % (x, y, z, zdir) ax.text(x, y, z, label, zdir)ax.text(9, 0, 0, &apos;red&apos;, color=&apos;red&apos;)ax.text2D(0.05, 0.95, &quot;20 text&quot;, transform=ax.transAxes)ax.set_xlim3d(0,10)ax.set_ylim3d(0,10)ax.set_zlim3d(0,10)ax.set_xlabel(&apos;X axis&apos;)ax.set_ylabel(&apos;Y axis&apos;)ax.set_zlabel(&apos;Z axis&apos;)plt.show() 地图绘制（mpl_toolkits.basemap） 基本思路 地图的大小、投影方法等重要信息，是在Basemap()的调用中实现的：map = Basemap(projection=’ortho’,lat_0=35,lon_0=120,resolution=’l’)projection参数规定了投影方法。改变投影方法，绘图结果也将非常不同。城市所在位置是经纬度。我们想要把经纬度对应图像的像素点，需要转换：x, y = map(lons, lats)这个语句转换为图像上的位置。最后，调用绘制散点图的方法scatter():cs = map.scatter(i,j,s=size,marker=’o’,color=’#FF5600’)在地图上画出数据。 准备数据 1234567891011# 保存到major_city.txt # 第一列是城市名，第二列是人口，第三第四列为纬度和经度，最后一列为所在国家。Shanghai 23019148 31.23N 121.47E ChinaMumbai 12478447 18.96N 72.82E IndiaKarachi 13050000 24.86N 67.01E PakistanDelhi 16314838 28.67N 77.21E IndiaManila 11855975 14.62N 120.97E PhilippinesSeoul 23616000 37.56N 126.99E Korea(South)Jakarta 28019545 6.18S 106.83E IndonesiaTokyo 35682460 35.67N 139.77E JapanPeking 19612368 39.91N 116.39E China 绘图代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltimport numpy as np#============================================# read datanames = []pops = []lats = []lons = []countries = []for line in file(&quot;../data/major_city&quot;): info = line.split() names.append(info[0]) pops.append(float(info[1])) lat = float(info[2][:-1]) if info[2][-1] == &apos;S&apos;: lat = -lat lats.append(lat) lon = float(info[3][:-1]) if info[3][-1] == &apos;W&apos;: lon = -lon + 360.0 lons.append(lon) country = info[4] countries.append(country)#============================================# set up map projection with# use low resolution coastlines.map = Basemap(projection=&apos;ortho&apos;,lat_0=35,lon_0=120,resolution=&apos;l&apos;)# draw coastlines, country boundaries, fill continents.map.drawcoastlines(linewidth=0.25)map.drawcountries(linewidth=0.25)# draw the edge of the map projection region (the projection limb)map.drawmapboundary(fill_color=&apos;#689CD2&apos;)# draw lat/lon grid lines every 30 degrees.map.drawmeridians(np.arange(0,360,30))map.drawparallels(np.arange(-90,90,30))# Fill continent wit a different colormap.fillcontinents(color=&apos;#BF9E30&apos;,lake_color=&apos;#689CD2&apos;,zorder=0)# compute native map projection coordinates of lat/lon grid.x, y = map(lons, lats)max_pop = max(pops)# Plot each city in a loop.# Set some parameterssize_factor = 80.0y_offset = 15.0rotation = 30for i,j,k,name in zip(x,y,pops,names): size = size_factor*k/max_pop cs = map.scatter(i,j,s=size,marker=&apos;o&apos;,color=&apos;#FF5600&apos;) plt.text(i,j+y_offset,name,rotation=rotation,fontsize=10)plt.title(&apos;Major Cities in Asia &amp; Population&apos;)plt.show() 以上是常用的matplotlib绘图方法，一下子可能很难全部记住，但是没关系，只要记得回来copy即可。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Swagger工具生成API文档]]></title>
    <url>%2F2018%2F11%2F29%2Fgeoist20181129.html</url>
    <content type="text"><![CDATA[要实现微服务框架API接口必不可少，使用Swagger工具可以更加方便的生成API框架和对应的接口文档。 首先，在swaggerhub.com上面注册一个账户，选免费的即可 根据示例工程，自己在编辑器中修改既可以看到API文档情况。 其次，如果想保存这些API文档，而可以通过设置于Github账号同步，直接同步到github账号下的指定仓库。 保存设计的API接口后，在swaggerHub网站的项目下，找到Add New Integrations，添加一个GitHub sync。保持账户登陆状态既可以生成token到swaggerhub，设置存放仓库路径即可。 我测试了server stub下面的nodejs-server生成类型，同步到github网站后，在客户端用git工具，打开git bash。直接运行 1npm start 最后，如果从git上面下载到本地后。执行正确，在本机输入http://localhost:8080/docs/，可以看到下图： PS:通过自动生成的API文档，可以通过github仓库进行保存，再通过CD工具，可以部署到docker或者远程服务器，将API文档发布出来。当然也可以直接在swaggerhub上面浏览或用第三方工具如ReDoc来直接通过GitHub的pages功能进行发布（由于pages只能发布静态网页，所以nodejs项目的执行必须通过工具先生成静态网页才可以运行，如Hexo建站原理类似）。 github上测试项目地址，https://igp-gravity.github.io/geoistapi/]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试第一个NB微服务]]></title>
    <url>%2F2018%2F11%2F28%2Fgeoist20181128.html</url>
    <content type="text"><![CDATA[尝试了一下kernelgateway的notebook_http功能 因为Geoist的定位就是将封装后的地球物理学代码共享给更多的用户使用，所以让python程序以微服务框架为大家服务是理想的解决方案之一。今天在出差的路上没忍住，亲测了一下让Jupyter Notebook变为微服务的kernelgateway服务。作为Jupyter系列项目中的一个，这个功能还是很酷的，只要通过简单的改造，你的nb程序就可以变成microservice啦 首先启动Jupyter Notebook，写一个ipynb文件，本次测试的代码如下： 开始第一个代码块cell 12import mathimport json 再写第二个代码块 12345678910# GET /convertreq = json.loads(REQUEST)args = req[&apos;args&apos;]if &apos;angle&apos; not in args: print(json.dumps(&#123;&apos;convertedAngle&apos;:None&#125;))else: angle = int(args[&apos;angle&apos;][0]) converted = math.radians(angle) print(json.dumps(&#123;&apos;convertedAngle&apos;:converted&#125;)) 注意上面的# GET /convert，这个是关键，convert代表将来的微服务入口，这个cell的前三行是固定写法，记下来。里面的print是返回的内容。 写好没问题后，保存到本地，注意目录要能通过http访问到。运行命令不容易记，写在这里吧 1jupyter kernelgateway --KernelGatewayApp.api=&apos;kernel_gateway.notebook_http&apos; --KernelGatewayApp.seed_uri=&apos;kgtest.ipynb&apos; ps：如果出现signal相关错误，可以通过尝试conda update ipykernel解决 演示NB脚本 更多kernelgateway的技术手册]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试Kubernetes部署和容器服务]]></title>
    <url>%2F2018%2F11%2F27%2Fgeoist20181127.html</url>
    <content type="text"><![CDATA[通过 microk8s使用Kubernetes结合Azure pipeline实现CD工作 折腾了几天MS的Azure pipeline在build阶段的任务终于配置好了，但是在release阶段一直没搞定。今天用了1元券在MS的Azure上面开了一个虚拟机，准备装个大名鼎鼎的k8s，世纪互联上总是比国外的慢不少，虽然是官方在11月中旬已经宣布登陆中国市场，但是在国内Azure上还没找到，自己手动装一个吧。前面坑不少，这几天总算把Azure DevOps的部署环境搞明白了，界面比Travis-CI高大上，但是感觉坑比那个多一些，没办法先当小白吧，一个一个坑爬过去，先把经验写到这里以便给自己给可能需要的人一些帮助… 在Azure世纪互联建立Ubuntu LTS虚拟机，通过Snap安装microk8s。 microk8s是一个简化版的kube用于测试和单机部署，一行命令即可完成安装。 1snap install microk8s --classic 为了不和已经安装的 kubectl 产生冲突，microk8s 有自己的 microk8s.kubectl 命令 1microk8s.kubectl get services 如果本地没有 kubectl 命令可以增加一个别名 1snap alias microk8s.kubectl kubectl 或者取消 1snap unalias kubectl API 服务监听 8080 端口,如果是在Azure云上面的虚拟机上面安装，需要安全配置里面打开端口 1microk8s.kubectl config view 查看附加组件。 1Kubernetes Addons microk8s 只是最精简的安装，所以只有 api-server, controller-manager, scheduler, kubelet, cni, kube-proxy 被安装运行。额外的服务比如 kube-dns, dashboard 可以通过microk8s.enable 启动 1microk8s.enable dns dashboard 禁用 1microk8s.disable dns dashboard 可用的扩展 dns dashboard storage ingress gpu istio registry metrics-server 停止或重启 microk8s 12snap disable microk8s # 停止snap enable microk8s # 重启 移除 12microk8s.resetsnap remove microk8s 安装完环境后，定义pod，首先要用vi新建一个hello-world-pod.yaml，保存 12345678910apiVersion: v1kind: Podmetadata: name: hello-worldspec: restartPolicy: OnFailure containers: - name: hello image: &quot;ubuntu&quot; command: [&quot;/bin/echo&quot;,&quot;hello”,”world&quot;] 字段解释 12345678910apiVersion: 声明K8s的API版本kind: 声明API对象的类型，这里是Podmetadata:设置Pod的元数据 name: hello-world 指定Pod的名称Pod名称必粗在Namespace内唯一spec:配置Pod的具体规格 restartPolicy: 重启策略 containers:容器规格，数组形式，每一项定义一个容器 - name:指定容器的名称，在Pod的定义中唯一 image:设置容器镜像 command:设置容器的启动命令 定义和创建pod 1kubectl create -f hello-world-pod.yaml 查询pod信息 1kubectl get pod hello-world 输出pod信息 1kubectl get pod hello-world --output json 状态和生命周期查询 1kubectl describe pod hello-world 更多参考：https://github.com/ubuntu/microk8s]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念第一个DevOps项目框架完成]]></title>
    <url>%2F2018%2F11%2F26%2Fgeoist20181126.html</url>
    <content type="text"><![CDATA[我们第一个地球物理开源项目，期望这是梦想的开始… 经过2周多组里的人努力工作，终于完成了一套协同工作环境 自动化文档、自动化集成和自动化部署，世界变化真快，从今开始实践Agile的软件设计方法 项目地址https://github.com/igp-gravity/geoist 参考文档https://geoist.readthedocs.io 我们的组织也有了，欢迎大家一起和我们践行现代化软件研发实践和共享精神https://github.com/gravity-igpcea 看着这些小图标，是不是有点高大上]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter NB秒变微服务的利器]]></title>
    <url>%2F2018%2F11%2F25%2Fgeoist20181125.html</url>
    <content type="text"><![CDATA[Jupyter Kernel Gateway这个工具可以帮你把写好的notebook变为REST api 原文可参考：https://ndres.me/post/jupyter-notebook-rest-api/ 安装1conda install -c conda-forge jupyter_kernel_gateway 启动1jupyter kernelgateway 在这个kernel的基础上，还可以进一步使用Jupyter Enterprise Gateway将你的cluster集群变成服务群。 这个项目的地址可以找到更多参考信息：https://github.com/jupyter/enterprise_gateway]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geoist自定义节点]]></title>
    <url>%2F2018%2F11%2F15%2Fgeoist20181115.html</url>
    <content type="text"><![CDATA[今天的工作进展 第一，实现了自定义界面的设计，通过数据源绑定和参数设计，采用vue框架下的HTML设计，可以提高用户体验； 第二，初步完成了5个节点的封装，实现了Pandas的Dataframe数据类型和网格Grid两种类型的数据处理和流转； 第三，注册到Datist节点库，并在Geoist的GitHub线上的extension目录下进行统一管理。]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的Geoist图标诞生了]]></title>
    <url>%2F2018%2F11%2F14%2Fgeoist20181114.html</url>
    <content type="text"><![CDATA[Geoist图标设计 开源的Geoist软件包，很快就要和大家见面了，DevOps的持续交付软件实践，为地学开源软件贡献一份力量。]]></content>
      <tags>
        <tag>geoist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Geoist？]]></title>
    <url>%2F2018%2F11%2F13%2Fgeoist20181113.html</url>
    <content type="text"><![CDATA[基于Python的开源地球物理软件包-Geoist Geoist是基于Python语言的开源程序包，面向地球物理研究生、教学科研人员，也可为原型化的地球物理算法设计和科研提供基础软件服务。程序包功能包括：重磁位场数据处理、反演解释和模型评估；高精度时变重力数据平差等。 该程序包采用MIT开源协议，并在Github上进行公开发布和维护，代码编写遵循PEP8规范。Geoist程序包采用模块化设计，用户可基于Geoist程序包进行二次开发和集成应用。 项目网站：https://github.com/igp-gravity/geoist 更多关于Geoist]]></content>
  </entry>
  <entry>
    <title><![CDATA[Geoist计划正式启航]]></title>
    <url>%2F2018%2F11%2F12%2Fgeoist181111.html</url>
    <content type="text"><![CDATA[Geoist项目计划即将出炉]]></content>
  </entry>
  <entry>
    <title><![CDATA[参加微软亚洲研究院二十年庆典]]></title>
    <url>%2F2018%2F11%2F11%2Finvo20.html</url>
    <content type="text"><![CDATA[参加微软亚洲研究院20周年庆典1998-2008二十年历程，5000+论文产出，开放合作，创新模式值得学习。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ISPEC团队应邀参加2018微软技术生态大会]]></title>
    <url>%2F2018%2F10%2F28%2Fmssummit2018.html</url>
    <content type="text"><![CDATA[ISPEC团队应邀参加2018微软技术生态大会 2018年10月24日-27日，由地球所牵头的“地震分析会商技术系统建设”项目团队，应邀参加在上海世博中心举行的微软技术暨生态大会（Microsoft Tech Summit 2018），并以“微软LUIS语义理解模型在地震会商技术系统中的应用”为题，进行了最新的地震行业AI技术成果分享。建立现代化与智能化地震会商技术平台系统，发挥现代科技优势，是提高地震预测预报服务能力的关键。地震分析会商技术系统是支持会商分析信息化、智能化的技术平台。通过自然语言处理（NLP）技术成果，地震行业团队基于微软LUIS语义理解模型和Bot框架，改进了原有的GUI设计，通过小G地震科研助手针对不同情景设计并实现了从前端的语义模型定义到后端服务流程匹配的全链条功能，初步搭建了一套新型交互式地震会商技术系统V1.0版本，并初步具备列装条件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小店开张喽！！！]]></title>
    <url>%2F2018%2F02%2F03%2Fhello-world.html</url>
    <content type="text"><![CDATA[欢迎来到 小G俱乐部! 地震科研助手经过2017年的积累，有了一个不错的开局，而2018年是新的征程即将开启。首先，作为流程化技术支撑Datist软件，正式推出了官方文档 . 其次，通过在 GitHub建立开放的仓库，期望能进一步吸收社会化编程的积极思想，推动构建地震行业的业务平台建设进程. 展望2018新的目标1以新的科技的力量，为地震行业业务体制改革提供技术保障。 新的起点1大数据、人工智能和平台技术三股力量同时发力。 新的任务1打造防震减灾领域互联网+型的新生态系统。]]></content>
  </entry>
  <entry>
    <title><![CDATA[让科研生涯更开放]]></title>
    <url>%2F2018%2F01%2F21%2Ftest.html</url>
    <content type="text"><![CDATA[我的个人科研站点最近研究了一下 githubs pages 建站方法，io域名，完全免费，适合“穷苦”的科研人员啊 科研主页 steveshichen.github.io 地震科普写作 chenshi.readthedocs.io 还有我目前做的两个项目 重力平差项目 steveshichen.github.io/bayadj 三维反演项目 steveshichen.github.io/gravinv 再公布一下我个人的github账号，steveshichen ，与该站账号不同的是，这里面有关于我负责项目的最新科研进展。 欢迎大家关注，star吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[完全测试帖]]></title>
    <url>%2F2018%2F01%2F20%2Ftoday.html</url>
    <content type="text"><![CDATA[今天工作很顺利，天气也很好]]></content>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识图谱点滴]]></title>
    <url>%2F2018%2F01%2F18%2Fkb.html</url>
    <content type="text"><![CDATA[关于知识图谱的技术发展，已经看了一段时间资料了，一点知识留此存照 知识图谱文献]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年第一贴]]></title>
    <url>%2F2018%2F01%2F16%2Fmy-first-blog.html</url>
    <content type="text"><![CDATA[新领地建好了github pages + Hexo + Next为我提供了新的工作平台，Cheers！]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
